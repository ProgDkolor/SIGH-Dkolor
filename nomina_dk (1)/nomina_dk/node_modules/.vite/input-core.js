import {
  __commonJS
} from "./chunk-Z47AEMLX.js";

// node_modules/input-core/lib/functions/defineMaskList.js
var require_defineMaskList = __commonJS({
  "node_modules/input-core/lib/functions/defineMaskList.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function defineMaskList(mask, format) {
      if (!mask) {
        return [];
      }
      var stack = [];
      var escape = false;
      mask.split("").forEach(function(maskChar) {
        var item = format[maskChar];
        if (escape && item) {
          item = null;
          escape = false;
        }
        if (!item) {
          if (!escape && maskChar === "\\") {
            escape = true;
            return;
          }
          escape = false;
          stack.push({
            char: maskChar
          });
          return;
        }
        if (item.regexp) {
          stack.push(item);
        }
      });
      return stack;
    }
    exports.default = defineMaskList;
  }
});

// node_modules/input-core/lib/constants/CharTypesEnum.js
var require_CharTypesEnum = __commonJS({
  "node_modules/input-core/lib/constants/CharTypesEnum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CharTypes;
    (function(CharTypes2) {
      CharTypes2[CharTypes2["USER"] = 1] = "USER";
      CharTypes2[CharTypes2["CHAR"] = 2] = "CHAR";
      CharTypes2[CharTypes2["MASK"] = 3] = "MASK";
    })(CharTypes = exports.CharTypes || (exports.CharTypes = {}));
  }
});

// node_modules/input-core/lib/functions/buildInputStrings.js
var require_buildInputStrings = __commonJS({
  "node_modules/input-core/lib/functions/buildInputStrings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CharTypesEnum_1 = require_CharTypesEnum();
    function buildInputStrings(data, mask, input, maskChar, maskString, selection) {
      var value = [];
      var valueIndex = 0;
      var pastedIndex = 0;
      var maskedValue = "";
      var inputValuesApplied = 0;
      function processMaskPartAsChar(maskPart, pastedValuesStack, item) {
        if (pastedValuesStack && pastedValuesStack[0] === maskPart.char) {
          pastedIndex++;
        } else {
          if (item && (item.char === maskPart.char || item.type !== CharTypesEnum_1.CharTypes.USER) || input) {
            valueIndex++;
          }
        }
        value.push({
          char: maskPart.char,
          type: CharTypesEnum_1.CharTypes.CHAR
        });
        if (pastedValuesStack) {
          inputValuesApplied++;
        }
        maskedValue += maskPart.char;
      }
      function processMaskPartAsRegExp(maskPart, maskIndex, pastedValuesStack, item) {
        var part = null;
        if (pastedValuesStack) {
          var i = 0;
          while (!maskPart.regexp.test(pastedValuesStack[i]) && pastedValuesStack.length > i) {
            i++;
            pastedIndex++;
          }
          if (pastedValuesStack.length > i) {
            pastedIndex++;
            inputValuesApplied++;
            valueIndex++;
            part = pastedValuesStack[i];
            value.push({
              char: part,
              type: CharTypesEnum_1.CharTypes.USER
            });
            maskedValue += part;
          }
        }
        if (part) {
          return;
        }
        if (item && item.type === CharTypesEnum_1.CharTypes.CHAR && data.length > valueIndex + 1) {
          valueIndex++;
          processMaskItem(maskPart, maskIndex);
          return;
        }
        if (item && item.type === CharTypesEnum_1.CharTypes.USER && maskPart.regexp.test(item.char)) {
          value.push({
            char: item.char,
            type: CharTypesEnum_1.CharTypes.USER
          });
          maskedValue += item.char;
          valueIndex++;
          return;
        }
        part = maskString ? maskString[maskIndex] : maskChar;
        value.push({
          char: part,
          type: CharTypesEnum_1.CharTypes.MASK
        });
        if (data.length > maskIndex) {
          valueIndex++;
        }
        maskedValue += part;
      }
      function processMaskItem(maskPart, maskIndex) {
        var item = data.length > valueIndex ? data[valueIndex] : null;
        var pastedValuesStack = null;
        if (selection.start <= maskIndex && pastedIndex < input.length) {
          pastedValuesStack = input.slice(pastedIndex);
        }
        if (maskPart.char) {
          return processMaskPartAsChar(maskPart, pastedValuesStack, item);
        }
        if (maskPart.regexp) {
          return processMaskPartAsRegExp(maskPart, maskIndex, pastedValuesStack, item);
        }
      }
      mask.forEach(function(maskPart, maskIndex) {
        processMaskItem(maskPart, maskIndex);
      });
      return {
        value,
        maskedValue,
        inputValuesApplied
      };
    }
    exports.buildInputStrings = buildInputStrings;
  }
});

// node_modules/input-core/lib/functions/inputValue.js
var require_inputValue = __commonJS({
  "node_modules/input-core/lib/functions/inputValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CharTypesEnum_1 = require_CharTypesEnum();
    var buildInputStrings_1 = require_buildInputStrings();
    function inputValue(params) {
      var data = params.data, _a = params.input, input = _a === void 0 ? "" : _a, selection = params.selection, mask = params.mask, maskChar = params.maskChar, maskString = params.maskString;
      var _b = buildInputStrings_1.buildInputStrings(data, mask, input, maskChar, maskString, selection), value = _b.value, maskedValue = _b.maskedValue, inputValuesApplied = _b.inputValuesApplied;
      var selectionPosition = selection.start + inputValuesApplied;
      var bound = value.length - 1;
      var charsCount = 0;
      while (bound >= 0 && value[bound].type !== CharTypesEnum_1.CharTypes.USER) {
        if (value[bound].type === CharTypesEnum_1.CharTypes.MASK) {
          charsCount = 0;
        }
        if (value[bound].type === CharTypesEnum_1.CharTypes.CHAR) {
          charsCount++;
        }
        bound--;
      }
      bound += charsCount;
      var visibleValue = "";
      for (var i = 0; i <= bound; i++) {
        visibleValue += value[i].char;
      }
      return {
        value,
        visibleValue,
        maskedValue,
        selection: {
          start: selectionPosition,
          end: selectionPosition
        }
      };
    }
    exports.default = inputValue;
  }
});

// node_modules/input-core/lib/functions/removeSelectedRange.js
var require_removeSelectedRange = __commonJS({
  "node_modules/input-core/lib/functions/removeSelectedRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var CharTypesEnum_1 = require_CharTypesEnum();
    var copyMaskChar = function(count, maskChar) {
      var res = [];
      for (var i = 0; i < count; i++) {
        res.push({
          char: maskChar,
          type: CharTypesEnum_1.CharTypes.MASK
        });
      }
      return res;
    };
    var pasteMaskSymbols = function(maskString, maskChar, selection) {
      if (maskString) {
        var res = [];
        for (var i = selection.start; i < selection.end; i++) {
          res.push({
            char: maskString[i],
            type: CharTypesEnum_1.CharTypes.MASK
          });
        }
        return res;
      }
      return copyMaskChar(selection.end - selection.start, maskChar);
    };
    function removeSelectedRange(param) {
      var value = param.value, selection = param.selection, maskChar = param.maskChar, maskString = param.maskString;
      if (selection.end < selection.start) {
        var tmp = selection.end;
        selection.end = selection.start;
        selection.start = tmp;
      }
      if (selection.start === selection.end) {
        return value;
      }
      if (value.length > selection.start) {
        return value.slice(0, selection.start).concat(pasteMaskSymbols(maskString, maskChar, selection), value.slice(selection.end, value.length));
      }
      return value;
    }
    exports.default = removeSelectedRange;
  }
});

// node_modules/input-core/lib/index.js
var require_lib = __commonJS({
  "node_modules/input-core/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defineMaskList_1 = require_defineMaskList();
    var inputValue_1 = require_inputValue();
    var removeSelectedRange_1 = require_removeSelectedRange();
    var CharTypesEnum_1 = require_CharTypesEnum();
    exports.defaults = {
      maskFormat: [
        {
          str: "0",
          regexp: /[0-9]/
        },
        {
          str: "*",
          regexp: /./
        },
        {
          str: "a",
          regexp: /[a-zA-Z]/
        }
      ],
      maskChar: "",
      showMask: false,
      removeSelectedRange: removeSelectedRange_1.default
    };
    exports.createInput = function(params) {
      var maskString = params.maskString, reformat = params.reformat, _a = params.maskFormat, maskFormat = _a === void 0 ? exports.defaults.maskFormat : _a, _b = params.maskChar, maskChar = _b === void 0 ? exports.defaults.maskChar : _b;
      if (!reformat && !params.mask) {
        reformat = function(params2) {
          var str = params2.value.map(function(item) {
            return item.char;
          }).join("");
          return {
            value: params2.value,
            visibleValue: str,
            maskedValue: str,
            selection: params2.selection
          };
        };
      } else if (reformat) {
        params.mask = null;
      }
      if (maskString && maskString.length !== params.mask.length) {
        throw new Error("maskString must have same length as mask");
      }
      if (maskChar.length > 1) {
        throw new Error("maskChar must have only 1 char");
      }
      var maskFormatMap;
      var selection = { start: 0, end: 0 };
      var value;
      var maskedValue;
      var visibleValue;
      var mask;
      var callbacks = [];
      var interfaceMethods = {
        subscribe: function(callback) {
          callbacks.push(callback);
        },
        unsubscribe: function(callback) {
          callbacks = callbacks.filter(function(item) {
            return item !== callback;
          });
        },
        setMaskFormat: function(maskFormat2) {
          maskFormatMap = maskFormat2.reduce(function(store, item) {
            store[item.str] = item;
            return store;
          }, {});
        },
        setValue: function(data) {
          var result;
          if (reformat) {
            result = reformat({
              value: data,
              selection
            });
          } else {
            var dataList = void 0;
            if (Array.isArray(data)) {
              dataList = data;
            } else {
              dataList = [];
              for (var i = 0; i < data.length; i++) {
                dataList.push({ char: data[i], type: CharTypesEnum_1.CharTypes.USER });
              }
            }
            result = inputValue_1.default({ data: dataList, selection, mask, maskChar, maskString });
          }
          applyChanges(result);
        },
        setSelection: function(newSelection) {
          selection = newSelection;
        },
        getSelection: function() {
          return {
            start: selection.start,
            end: selection.end
          };
        },
        backspace: function() {
          interfaceMethods.removePreviosOrSelected();
        },
        removePreviosOrSelected: function() {
          if (selection.start === selection.end) {
            selection.start = selection.end - 1;
            if (selection.start < 0) {
              selection.start = 0;
            }
          }
          interfaceMethods.input("");
        },
        removeNextOrSelected: function() {
          if (selection.start === selection.end) {
            selection.end++;
          }
          interfaceMethods.input("");
        },
        getState: function() {
          return {
            value,
            maskedValue,
            visibleValue,
            selection
          };
        },
        setMask: function(newMask) {
          mask = defineMaskList_1.default(newMask, maskFormatMap);
          interfaceMethods.setValue(value);
        },
        setMaskChar: function(newMaskChar) {
          if (maskChar.length > 1) {
            throw new Error("maskChar must have only 1 char");
          }
          maskChar = newMaskChar;
          interfaceMethods.setValue(value);
        },
        setMaskString: function(newMaskString) {
          if (newMaskString && newMaskString.length !== mask.length) {
            throw new Error("maskString must have the same length as mask");
          }
          maskString = newMaskString;
          interfaceMethods.setValue(value);
        },
        setReformat: function(newReformat) {
          reformat = newReformat;
          interfaceMethods.setValue(value);
        },
        paste: function(value2) {
          interfaceMethods.input(value2);
        },
        input: function(input) {
          var result;
          if (reformat) {
            result = reformat({ value, input, selection });
          } else {
            var tmpValue = removeSelectedRange_1.default({ value, selection, maskChar, maskString });
            selection.end = selection.start;
            result = inputValue_1.default({ data: tmpValue, input, selection, mask, maskChar, maskString });
          }
          applyChanges(result);
        }
      };
      function applyChanges(result) {
        var oldMaskedValue = maskedValue;
        var oldVisibleValue = visibleValue;
        var oldSelection = selection;
        value = result.value;
        maskedValue = result.maskedValue;
        visibleValue = result.visibleValue;
        interfaceMethods.setSelection(result.selection);
        if (oldMaskedValue !== maskedValue || oldVisibleValue !== visibleValue || oldSelection.start !== selection.start || oldSelection.end !== selection.end) {
          notify();
        }
      }
      function notify() {
        var state = interfaceMethods.getState();
        callbacks.forEach(function(callback) {
          callback(state);
        });
      }
      interfaceMethods.setMaskFormat(maskFormat);
      mask = defineMaskList_1.default(params.mask, maskFormatMap);
      interfaceMethods.setValue(params.value);
      return interfaceMethods;
    };
  }
});

// dep:input-core
var input_core_default = require_lib();
export {
  input_core_default as default
};
//# sourceMappingURL=input-core.js.map
